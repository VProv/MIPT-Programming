#pragma once
// Нахождение максимального потока на графе алгоритмом "Поднять и в начало".
// Провилков Иван. гр.593.
#include <vector>
#include <list>
#include <algorithm>

using std::vector;
using std::list;
using std::min;

class CRaiseBegin {

public:

    CRaiseBegin( int _n, int _start, int _destination, const vector< vector<int> >& _c ) :
        c( _c ), neighbors( _n ), current( _n ), e(_n,0), h(_n,0), f( _n, vector<int>( _n, 0 ) ) 
    {
        n = _n;
        start = _start;
        destination = _destination;
    }

    // Подъем вершины.
    // Для переполненной вершины u применима операция подъема, если все вершины,
    // для которых в остаточной сети есть ребра из u, расположены не ниже u.
    // В результате подъема высота текущей вершины становится на единицу больше высоты самый низкой смежной вершины в остаточной сети, 
    // вследствие чего появляется как минимум одно ребро, по которому можно протолкнуть поток.
    void relabel( int u );

    // Операция может применяться когда вершина переполнена.
    void push( int u, int v );

    // Операция, применяемая к переполненной вершине u, для того чтобы протолкнуть поток через допустимые ребра в смежные вершины,
    // при необходимости поднимая u, делая недопустимые ребра, выходящие из вершины u, допустимыми.
    // Операция завершится только тогда, когда избыток e(u) станет равным нулю, и ни подъем, ни перемещение указателя current[u] не влияет на значение e(u).
    bool discharge( int u );
    // Инициализируем предпоток.
    void initializePreflow();

    // Сам алгоритм, возвращает значение максимального потока.
    int raiseToBegin();

private:
    // Количество вершин графа.
    int n;
    // Номер истока (с 0).
    int start;
    // Номер стока.
    int destination;
    // Предпоток.
    vector<vector<int> > f;
    // Начальные пропускные способности, наш граф.
    const vector<vector<int> >& c;
    // Высота вершин.
    vector<int> h;
    // Избыточный поток входящий в вершину.
    vector<int> e;
    // Для каждой вершины храним список смежных вершин, в том смысле что есть ребра uv или vu.
    vector<list<int> > neighbors;
    vector<list<int>::iterator > current;
};